day1
	
		
		
	
	1，Vue是什么：是一个用于创建用户界面的开源javascript框架，也是一个创建单页应用的web应用框架
	
	
	2，vue的特点：
		
		
		
		（1）响应式数据：数据驱动视图，可以让我们只关注数据的变化
		
			
		（2）MVVM的双向绑定：数据变化则视图变化，视图变化则数据变化
		
		
		（3）指令：增强了html功能的新特性，一个指令对应一种功能
	
		
		（4）组件化开发：提高复用性，解耦，提升未来的开发效率	
		
	

	3，vue的三种安装方式
			
		
		
		（1）采用本地文件引入的方式直接下载到目录中引入
		
		
		（2）采用在线cdn引入的方式：cdn相当于把一个文件放到了全国各地，然后你离那里近，就从哪里调拨给你。
		
		
		（3）采用npm的安装方式
	
		

	4，vue的使用过程
		
		
		（1）先创建一个vue的实例，接收一个对象作为参数，对象的第一个参数是el：用来管理页面中那一个元素的部分
		
		     值通常是id选择器，也可以是类选择器，或者其他选择器。但是管理的视图不能是body或者html。
		
			
			
			let vm = new Vue({
			
				el : "#app",
			});
		

		
		（2）对象的第二个参数是data：存储的都是响应式数据。可以通过mv.$data访问原始数据对象，vue中所有的原始数据都带$.
			
		     vue的实例vm也代理了data对象上的所有的属性，因此访问vm.a等同于vm.$data.a。视图中

		     显示的数据必须保存在data对象中
		
			
			
			let vm = new Vue({

				el : "#app",
			
				data : {
					
					name : "hahah"
				}
			});
		
			
		（3）对象的第三个参数methods：用来定位方法的。vm也代理$methods中的所有的方法。
		
		
			
			let vm = new Vue({

				el : "#app",
			
				data : {
					
					name : "hahah"
				},
				
				methods : {

					add() {
						
						console.log("aaa");
					}
				},
			});
		
	

		
	5，插值表达式：将绑定在data中的数据插入到页面中。通过{{ name }}形式来插进去。
		
		
		
		缺点：如果网速慢的话，请求vue没有响应，页面不会显示数据，而是会显示插值表达式
		

		特点：如果元素本身有内容的话不会覆盖掉，只会替换插值表达式部分		

	


	6，指令：扩展html5的功能一个指令一个功能。指令一般都设置在元素的身上
		
			
		
		
		v-text="表达式"：里面的表达式会被当做变量来解析。

		
			特点：如果元素中本身有内容，那么会覆盖原来的内容。并且他不能识别标签
			
			
			<p v-text="msg"></p>			


		v-html="表达式"：里面的表达式会被当做变量来解析。
		
		
			
			特点：如果元素中本身有内容，那么会覆盖原来的内容。并且他能识别标签
		
			
			<p v-html="msg"></p>		


		v-if="表达式"：根据表达式是true还是false决定元素是删除还是创建。
		
				
			
			缺点：有较高的性能切换开销

			
			<p v-if="flag">小明明明明明明明</p>
		
		
		
		v-show="表达式"：根据表达式是true还是false决定元素是隐藏还是删除。
			
			
			缺点：有较高的初始渲染开销
			
			
			<p v-show="flag">哈啊啊啊啊啊啊啊啊啊啊啊啊啊啊</p>
			

		v-on：标定事件的指令。用来绑定事件的他的值必须是一个函数
		
				
			格式：v-on:事件类型="事件处理程序"

			
				<button v-on:click="show" v-on:mouseover="run">登陆</button>

			简写：@事件类型="事件处理函数"
	
		
				<div id="app" @click="app">
			



			事件的修饰符：	
		

				
				（1）.stop：阻止事件冒泡。格式：@事件类型.stop
		
				
				（2）.prevent：阻止元素的默认的行为，格式：@事件类型.prevent
		
			
				（3）.capture：实现事件的捕获机制来执行事件处理程序。格式：@事件类型.capture，给最外面的元素设置
				
				
				（4）.self：只有触发了当前事件才会执行，冒泡上去的不会执行。格式：@click.self
		
			
				（5）.once：事件只能触发一次。格式：@click.once

			
				键盘事件修饰符：
			
					
					
				
					（1）.enter：只有按下回车键才会触发该事件
		
					
					（2）.tab：只有按下tab才会触发该事件
				
						
					（3）.space：只有按下space才会触发该事件
			
					
					（4）等等还有很多
				

	
					@keyup.space="add"

					
				
				自定义按键修饰符：
		
	
	
					Vue.config.keyCodes.end = 13;
		
				
					@keyup.end="add"
				


			
			获取事件对象的俩种方法：
			
				
				
				（1）定义事件函数的时候，第一个参数指定event，在@click="click"调用的时候，不加小括号，第一个参数默认就是事件对象
			
			
				
				（2）定义定义事件函数的时候，第一个参数指定event，在@click="click($event)"调用的时候，第一个参数，加上$就是事件对象，如果不加就是普通的传参


		
		v-bind:属性="表达式"：把vue中的data对象的数据绑定到元素的属性中
			
			
			简写格式：:属性="表达式"
		
			
			<div v-bind:style="style" @click="parent">
			
			
			通过他绑定的class属性可以给他传入一个数组，每一项要用单引号引起来 ，也可以传入对象，还可以用三元表达式
			
				
			<div id="div2" v-bind:class="['get','add','delete']">
		
			
			当flag为true的时候该类名可以使用，为false不可以使用

			<div id="div2" v-bind:class="{'get' : flag,'add' : false}">
		
		
			
		
		v-model="表达式"：可以实现数据的双向绑定，只能给表单元素设置
		
			
			<input type="text" v-model="msg">
				


			修饰符：
			
				
				
				.trim：去除俩边的空格
		
				
				.number：将用户输入的值转为数值类型
			

					v-model.trim="msg"




		v-for="(变量, 索引) in 要遍历的项"：如果不需要索引的话，可以把小括号去掉


		
			遍历数组中的对象
			
			<p v-for="user in list">{{user.name}}</p>
		
				
			遍历对象
			<p v-for="(val,key,i) in obj">
		
		
		v-for""和key属性的使用：如果没有这个属性的时候vue就使用就地服用策略，列表里的顺序发生改变的时候，vue为了提升性能，不去移动dom元素，只是更新相应元素的内容节点。值必须是字符串类型或者number类型。
		
			
			
			<div v-for="item in listData" :key="item.id">

				<p>{{item.id}}====<input type="checkbox" />=={{item.name}}</p>

			</div>
	
		
	

day2
	
	
	
	
	
	
	1，当v-if和v-for相遇：v-for的优先级会大于v-if。
		
		
		
	2，v-once指令：如果给元素加上该指令表示该元素只能被操作一次
		
			
		
		<p v-once>{{msg}}</p>
		
			
		

day3
	
		
		
	1，过滤器：必须有返回值的函数，用来过滤出想要的部分
		
			
		
		格式：{{msg + 1 +2 +3 | 过滤器名字}}或者 v-bind:属性="表达式 |`过滤器名称"。|：被叫做管道
		
			
			
		（1）全局过滤器：可以给任意多个Vue的实例使用
			
				
			
			用法：Vue.filter("名字", callback(value))：第一个参数是过滤器的名字，第二个参数是回调函数，函数的第一个参数始终都是需要过滤的值，调用的时候不需要传值，如果需要传递其他的参数，调用的时候就带上小括号，里面传值。
			
 			但是第一个参数，永远都是过滤器左边的值。如果有多个过滤器，在元素上使用 | 分开
		

			
		（2）局部过滤器：在Vue的实例对象中使用filters对象，里面定义过滤器函数，函数的名字就是过滤器。只能给当前vue的实例使用
			
			
			
			用法：filters {

				
				get(value) {}
			      }
		
			
			
		
	2，使用ref属性来操作DOM：给元素定义ref属性，然后通过this.$refs对象中包含了DOM元素和信息
				
				
		<input type="text" ref="myText">
		
		
		
		
	3，自定义指令：
		
			
		
		（1）全局自定义指令：可以给任意多的vue实例对象使用我们自己定义的指令
			
				
			格式：Vue.directive("名字",{})：对象里面接收以下的参数函数
			
				
				注意：el和bindding参数说明：
					
					
					（1）el：当前DOM元素。
			
					
					（2）bindding：是一个对象。记录了指令的名字，值等信息
			
				
				（1）bind(el, binding) {}：只调用一次，指令第一次绑定到元素上时使用，可以进行一次性初始化的设置
				
				
				
				（2）inserted(el, binding){}：被绑定的元素插入到父节点时使用，保证父节点存在就行，不一定非要插入。
					
							
				
				（3）update(el, binding){}：当元素的值被改变的时候调用
			
				
				
				（4）componentUpdated(el, binding)：当元素的值改变完成的时候调用
		
			
			
				（5）unbind(el, binding){}：当指令与元素解绑时调用，只调用一次	
		
		
			
			
		（2）局部自定义指令：只能给当前vue实例对象使用
		
		
	

			格式：directives : {

				
				指令的名字
				get : {
					
					
					（1）bind(el, binding) {}：只调用一次，指令第一次绑定到元素上时使用，可以进行一次性初始化的设置
				
				
				
					（2）inserted(el, binding){}：被绑定的元素插入到父节点时使用，保证父节点存在就行，不一定非要插入。
					
							
				
					（3）update(el, binding){}：当元素的值被改变的时候调用
			
				
				
					（4）componentUpdated(el, binding)：当元素的值改变完成的时候调用
		
			
			
					（5）unbind(el, binding){}：当指令与元素解绑时调用，只调用一次
			
				}

			      }		
	
		
		
	4，计算属性：
		
			
		
		格式：computed : {}：参数都是函数：我们在模板中双向绑定了一些数据，并且以插值表达式插入到元素内部，但是如果要进行其他的操作
				
				    比如说还想调用方法等等，会显得特别臃肿，不容易维护。
				
					
				
				作用：可以在计算属性中定义方法，来完成这些复杂的逻辑，调用的时候，不要加小括号，当属性一样去使用
					
				
				特点：
				
					
					（1）只要计算属性这个function内部的data中的数据发生了变化，就会立即重新计算，否则就使用缓存中的数据，性能优越，不会重新计算
				
				

		
			
	5，axios插件发生ajax请求：
			
			
			
		
		格式：axios.get(),axios.post(),axios.put(),axios.delete()
		
			
			
		
	
	6，json-server使用：可以快速的帮我们搭建一个后端的接口
		
			
		
		全局安装：npm i -g json-server
		
			
		
		使用方法：
		
			
			插件一个json文件，并且在该目录下运行命令 josn-server --watch data.json能够快速的产生一个接口
			
			
			
			1. 查询数据  GET  /brands 获取db.json下brands对应的所有数据列表

			2. GET /brands/1 查询id=1数据单条

			3. 删除数据 DELETE/brands/1 删除id=1数据

			4. 修改数据 PUT/brands/1 请求体对象

			5. 上传/添加 POST/brands 请求体对象
		
		
		
		
		data.json文件中的数据形式：
			
			
			
			{
  				"phone": [
    	
    					{
     						 "name": "西瓜",
     						 "date": "2019-12-11T01:16:42.622Z",
      						 "id": 15
   					 },

   					 {
   						   "name": "鸭梨",
     						   "date": "2019-12-11T01:25:00.802Z",
      						  "id": 16
   					 },
				]
			
			}
	
		
		
	7，mounted(){}：是一个事件函数，当vue实例对象加载完毕的时候调用。


	
	8，Vue.set(要更改的数据源， 要更改的具体的数据，重新改变的值)：加入我们的button元素的按钮没有在vue的控制范围，并且data的对象定义到全局，
		
		  这个时候，在button事件函数里面访问data里面数组带有下标的值的时候，vue是检测不到的，所有需要通过Vue.set()方法来设置
	
		
	
	
	9，Vue.config.keyCodes：用来自定义键盘修饰符，自定义的键盘修饰符等于键盘码。


		
			
		Vue.config.keyCodes.end = 13;



day4
	
	
	
	
	1，watch ： {}：一个对象键是需要观察的表达式，值是对应的回调函数，值也可以是方法名。是用来检测data里面的属性的。
		
	
	
	
	
		（1）当值是普通值的时候：data里面的属性名，就是函数。每次属性的值发生改变的时候，函数就会被调用
	

	
		
			格式：
	
	

	
	
				watch : {

					num(newVal, oldVal){}
				}
		
	

			
			格式2：immediate属性：如果值为true的话进入页面就立即出发
	
	

				watch : {

					
					num : {

		
						handler(newVal, oldVal) {

		
						}
					}

					
					immediate : true;
				}
		
		
			
		（2）当值是复杂数据类型的话：他存储的是地址，地址没有变的话是不会出发的，所以需要深度监听。设置deep属性为true就是深度监听
		

	
	
	
			格式：	

	
				
				watch : {

					
					num : {

		
						handler(newVal, oldVal) {

		
						}
					}

					
					immediate : true,

		
					deep : true,
				}
	
	
	

		（3）Watch和computed（计算属性）的区别：
	
		
	
			1，watch用于观察和监听页面上的vue实例，当你需要在数据变化响应时，执行异步操作，高性能消耗的操作，那么watch是最佳的选择
		
		
			
			2，可以关联多个实时计算的对象，当这些对象中的其中一个改变时都会触发这个属性。而且他可以缓存数据
	
	
	


		
	2，<component :is="comName"></component>：vue自定义的标签，通过is属性来决定绑定那个组件显示出来
	
	

						  如果is的值不是变量是直接的组件名字，需要加上单引号，因为组件的名字是字符串
		
	

	
		
	
	3，组件：组件是一个特殊的Vue的实例
	
	
		
		（1）组件的特点：

			
			1，复用性高
			
			
			2，代码容易维护	

	
		（2）创建组件的二种方法：
	
		
	
	
			1，第一种创建组件的方法：第一个参数是组件的名字，第二个参数是组件的模板
	
	

	
	
				Vue.component("myCom", Vue.extend({


					template : '<a href="#">组件</a>'
				}));
	
	
		
			2，第二种创建组件的方法：使用的是对象字面量的方法
	

	
				Vue.component("myCom", {

					template : '<a href="#">字面量模板-----{{msg}}</a>',
	
				});
		
		
		
		
		（3）全局组件：可以被所有的vue实例对象使用
			
			
			
			Vue.component("myCom", {

				template : '<a href="#">字面量模板-----{{msg}}</a>',
	
			);
		
	
			
			
		（4）局部组件：
	
	
	
			components : {
				
				组件的名字
				login : {

					template : '<a href="#">私有的组件</a>'
			 	},
			
			},
	
	
	

		（5）组件中的data：组件中的data必须是一个函数。
	
	
		
			（1）原因：每一个vue组件都是一个vue的实例，通过new Vue()，引向同一个对象，如果data直接是一个对象的话，，那么一旦修改其中一个组件的的数据，其他组件的数据也会吧诶改变。
			
			
			           如果data是一个函数的话，每个vue组件的data都因为函数有了自己的局部作用域，互不干扰
	

	
	
	
		（6）组件中的方法：组件中也有很多方法跟new Vue()中的方法一样
	
	

	
	
	
		（7）组件的嵌套：将定义的组件，嵌套到另一个组件中。
	
	
				将组件渲染到页面

			
					<dong></dong>
	
				
				父组件

				Vue.component("dong", {
								将子组件嵌套到父组件中
						
					template : "<div>哈哈哈哈<dong-child><dong-child><child></child></div>"
					
					
					可以继续定义局部组件
					components : {


						"dongChild" : {


							template : "#com1-1",

						}
					},
	
				});
	
	

				子组件
	
	
				Vue.component("child", {

				
					template : "<p>哈哈哈</p>"
	
				});
	

	
	

		（8）父组件给子组件传值：通过props来接收父组件的值，就是接收new Vue()中的data中的值，通过绑定属性的方法绑定的模板上去，属性的值必须是data中的属性
	
			
			将组件渲染到页面通过绑定属性来传值

			<dong :name="msg"><dong>


				
			Vue.component("dong", {

	
				template : "<div>hahahha</div>"

				通过他来接收父组件的传值，通过this.name来获取到
				props : ["name"]
			});
			

			
			let vm = new Vue({

	
				el : "app",

				data : {
			
					
					msg : "hahah"
				},
			});

			
	
		（9）子组件给父组件传值：
	
			
			将组件渲染到页面中去

			
			<button @click="add"></button>

							
			<dong @type="fn"></dong>

		
			Vue.component("dong", {	

	
				template : "<div>哈哈哈哈</div>",

				
				methods : {


					add() {

						
						//触发自定义事件，让父元素来追踪子元素的数据

						
						this.$emit("type", 传递过去的参数);
					}
	
				}
			});

	
			let vm = new Vue({

	
				el : "app",

				data : {
			
					
					msg : "hahah"
				},

	
	
				methods : {
	

					add(传递过来的参数) {

						追踪子组件参数的函数
				
						
						console.log(传递过来的参数);
					
					}
				}
			});
	
		




	
	4，spa（single page, application）前端路由：
	
	
					

		（1）概念：只有一个web页面的应用，是加载单个html页面，并在用户与应用程序交互时，动态更新该页面的web应用程序
	

	
		（2）优点和缺点：
	
	

	
			1，优点：
	
	
	

				（1）减轻服务器端的压力
	
	
				（2）提高了页面的渲染效果
	
	
				（3）提高了用户的体验
	
	
			2，缺点
	
	

	
				（1）首次加载页面很慢
			
			
				（2）SEO搜索引擎不友好
	
		
			
		（3）spa的实现原理：
	
	
	
	
			（1）浏览器中的哈希值与展示视图内容之间的对于规则。路由就是hash和component的对应关系
	
	
	

		（4）vue-router-文档：是vue.js官方的路由管理器，第三方的插件
	
	
	
			
		（5）vue-router的使用步骤：
	
	
	
	
			<div id="app">

		
				 <!-- 第一步设置路由的导航 -->

				 <router-link to="/food">食物</router-link>

		
				 <!-- 第二步设置一个容器，容器必须有 -->

        			 <router-view></router-view>

			</div>

	
	
	
			//第三步实例化一个rooter路由对象

			let router = new VueRouter({

				//第四步配置路由列表

				routes : [

					{	
						//path是路径
						 path : "/food", 

						//组件
						component : {

							template : `<div>猪肉鱼肉鸭头</div>`,
						}
					},
			
				]
			});
	

	
	
	
			let vm = new Vue({

				el : "#app",

				data : {},

				methods : {},


				//最后将router的实例挂在vue实例上


				router : router
			});
	
	
	
	
	

	
day5
	
	

	
		
	1，动态路由：组件标签携带的参数不同，但是可以进入同一个组件，可以动态的控制组件。那么path路径就不能写死，如果要接收参数，在接收参数的部分加上:冒号，之后就是一个变量了，可以获取不同组件标签访问同一个路由，并且可以获取到他们传递过来的参数	
		
		
		    通过$route.params.name来获取参数			


		
		<div id="app">
		
			<router-link to="/city/上海">上海</router-link>

			<router-link to="/city/北京">北京</router-link>

			<router-link to="/city/张家口">张家口</router-link>

			<router-view></router-view>
		</div>
		
		
		let router = new VueRouter({

			routes : [

				{		此时的name就成为了一个变量，可以接收组件标签传递过来的参数	
					
					path : "/city/:name",

					component : {

						template : `
						
							<div>你点击的城市是{{$route.params.name}}</div>
					`
					}
				}
			],
		});		


		
		let vm = new Vue({

			el : "#app",

			data : {},

			methods : {},

			router,
		});
	
	
		
	
	2，路由组件标签vue-router-to属性赋值的几种方式：
	
	
	
	

		（1）普通字符串：就是死的路径，不能接收传递的参数
			
	
	
			
	
			<div id="app">
		
				<router-link to="/city/name">上海</router-link>

				<router-link to="/city/name">北京</router-link>

				<router-link to="/city/name">张家口</router-link>

				<router-view></router-view>
			</div>
		
		
			let router = new VueRouter({

				routes : [

					{		此时的name就成为了一个变量，可以接收组件标签传递过来的参数	
					
						path : "/city/name",
	
						component : {

							template : `
						
								<div>你点击的城市是{{$route.params.name}}</div>
							`
						}
					}
				],
			});		


		
			let vm = new Vue({

				el : "#app",

				data : {},

				methods : {},

				router,
			});
		


			
		（2）对象形式：
	
	
	
			
			<div id="app">
		
				<router-link :to="{path : '/city/name'}">上海</router-link>

				<router-link :to="{path : '/city/name'}">北京</router-link>

				<router-link :to="{path : '/city/name'}">张家口</router-link>

				<router-view></router-view>
			</div>
		
		
			let router = new VueRouter({

				routes : [

					{		此时的name就成为了一个变量，可以接收组件标签传递过来的参数	
					
						path : "/city/name",
	
						component : {

							template : `
						
								<div>你点击的城市是{{$route.params.name}}</div>
							`
						}
					}
				],
			});		


		
			let vm = new Vue({

				el : "#app",

				data : {},

				methods : {},

				router,
			});
				
		

			
		（3）自定义属性：
	
	

	
			<div id="app">
		
				<router-link :to="{name : abc}">上海</router-link>

				<router-link :to="{name : abc}">北京</router-link>

				<router-link :to="{name : abc}">张家口</router-link>

				<router-view></router-view>
			</div>
		
		
			let router = new VueRouter({

				routes : [

					{		此时的name就成为了一个变量，可以接收组件标签传递过来的参数	
					
						path : "/city/name",
						
						name : "abc",						

						component : {

							template : `
						
								<div>你点击的城市是{{$route.params.name}}</div>
							`
						}
					}
				],
			});		


		
			let vm = new Vue({

				el : "#app",

				data : {},

				methods : {},

				router,
			});
		
	
		
		（3）对象带参数：
	
	
	

			<div id="app">

		
				<router-link :to="{name : abc, params : {name : "上海"}}">上海</router-link>


				<router-view></router-view>
			</div>
		
		
			let router = new VueRouter({

				routes : [

					{		此时的name就成为了一个变量，可以接收组件标签传递过来的参数	
					
						path : "/city/:name",					
						
						name : "index",

						component : {

							template : `
						
								<div>你点击的城市是{{$route.params.name}}</div>
							`
						}
					}
				],
			});		


		
			let vm = new Vue({

				el : "#app",

				data : {},

				methods : {},

				router,
			});
			
		
		
	
	3，路由的重定向：
	
	
	
		（1）概念：当希望某个页面被强制中转时，可采用redirect进行路由重定向设置，在配置路由对象中设置，是一个属性，值是要强行跳转的地址
	
	
			
			<div id="app">
		
				<router-link to="/city/sh">上海</router-link>

				<router-link to="/city/bj">北京</router-link>

				<router-link to="/city/zjk">张家口</router-link>

				<router-view></router-view>
			</div>
			
			let router = new VueRouter({

				routes : [

					{
						path : "/city/sh",

						component : {

							template : "<div>您取得是上海<div>"
						}
					},

					{
						path : "/city/bj",

						//设置重定向当路由到北京的时候拦截重定向到张家口

						redirect : "/city/zjk",

						component : {

							template : "<div>您取得是北京<div>"
						}

					},

					{
						path : "/city/zjk",

						component : {

							template : "<div>您取得是张家口<div>"
						}

					}
				],
			});			


			let vm = new Vue({

				el : "#app",

				data : {},

				methods : {},

				router,
			});
		
		
			
	4，编程式导航：跟router-link一样，都能实现组件之间的跳转，router-link是根据a标签进行跳转的，而导航式通过绑定click事件，调用$router来进行跳转的。this.$router可以拿到当前路由的实例

		
		（1）跳转的方法：
	
	
			1，this.$router.push(path)：往历史记录了推了一条记录，如果点击浏览器的返回上一页按钮，可以返回上一页
			
			
			2，this.$router.replace(path)：替换了当前的记录历史记录并没有多，但是地址会变
			
			
			3，this.$router.go(number)：代表是前进还是后退，数字大于0是前进，小于0是后退

	
			
		<div id="app">
			
			
			容器必须有
			<router-view></router-view>
		</div>
		
	
		let objA = {

			template : `<div>
		
				我是A页面我要去B页面
				<button @click="goB">去B页面</button>	
			</div>`,

			methods : {

				goB() {

					//使用push方法会有历史记录，可以返回到上一个页面
					this.$router.push("/B");
				
					//第二种方法
				
					// router.push("/B");
					console.log(this.$router);
				}
			}
		}

		let objB = {

			template : `
			
				<div>我是B，我要去C
				
					<button @click="goC">去C页面</button>
				</div>
			`,

			methods : {

				goC() {

					// replace：替换当前的记录
					this.$router.replace("/C");
				}
			}

		}
		let objC = {

			template : `<div>C页面，我要去A页面
			
				<button @click="goA"></button>
			</div>`,

			methods : {

				goA() {

					// go：后退后退多少页，大于0是前进，小于0是后退
					this.$router.go(-1);
				}
			}
		}
		
		
		配置路由表
		let router = new VueRouter({

			routes : [

				{path : "/", redirect : "/A"},
				{path : "/A", component : objA},
				{path : "/B", component : objB},
				{path : "/C", component : objC}
			],
		});
		
			
		
		
	5，路由激活样式：可以改变当前点击组件的class样式
	
	
		
		let router = new VueRouter({

			//通过linkActiveClass可以改变组件标签的class属性
			linkActiveClass : "dong",	

			routes : [

							//当点击北京的时候强制重定向到重庆

				{path : "/bj", redirect : "cq", component : temp},

				{path : "/sh", component : temp2},

				{path : "/cq", component : temp3}

			]
		});

	
		let vm = new Vue({

			el : "#app",

			data : {},

			methods : {},

			router,
		});
	
	
	6，路由的嵌套：
	
		

		let router = new VueRouter({


			routes : [

				{
					path : "/city/bj",
					

					//设置二级路由导航
					
					children : [
						
						{
							path : "cp",
							
							component : {

	
								template : "<div>昌平区</div>"
							}
						},

						{
							path : "hd",
							
							component : {

	
								template : "<div>海淀区</div>"
							}
						},

						{
							path : "cy",
							
							component : {

	
								template : "<div>朝阳区</div>"
							}
						},

					],
					
					component : {

						template : "<div>
		
							<p>这是北京</p>
							

							//设置二级组件标签
							<router-link to="cp">昌平</router-link>

							<router-link to="hd">海淀</router-link>

							<router-link to="cy">朝阳</router-link>
	
						</div>"
					}
				
				}
			]
		});
	
	
		let vm = new Vue({

			el : "#app",

			data : {},

			methods : {},

			router,
		});
	
	

	
	

	
	7，vue-cli工具的介绍：
		
	

	
		（1）是一个开发脚手架，是一个开发辅助工具用于自动生成vue.js+webpack的项目模板
	
	
	
	
		（2）安装方法：
	
	
	
			1，全局安装：npm i  -g @vue/cli 默认的版本是4.0+
	
	
	
	
			2，补全2.0版本：npm i -g @vue/cli-init 把2.0的版本也补上
	
	
			
		（3）使用脚手架：
	
	

			（1）使用2.0版本：
	
	

				1，vue init webpack-simple 项目名称    创建一个项目
		
				
				
				2，cd 项目名称 切换到当前的项目
	
	
				
				3，npm i   安装依赖
	
	
				
				4，npm run dev   启动运行项目
		
	
	
			（2）使用4.0版本：
	
		
	
	
				1，vue create 项目名称     创建项目
	
		
	
		
				2，cd 项目名称     进入项目
	
	

				3，npm run serve    启动项目
	
		
		
			
		（4）项目目录的介绍：
	
	
	
	
			（1）bablelrc：es6特性浏览器还没有全部支持，但是使用es6是大势所趋，所以babel用来将es6代码转成浏览器能够识别的代码。
			
				
			
			（2）editorconfig：存放的是编译器的配置信息
	

	
			（3）gitignore：可以获取一些不需要提交的文件。
	
		

			（4）index.html ：单页应用的html
			

			
			（5）package.json：用于存放依赖信息及其它的项目信息

	

			（6）README.md：项目的介绍信息
	
	
	
			（7）webpack.config.js：wepack工具的配置文件。webpack是一个前端工程化的工具  编译代码 -压缩代码- 处理代码,其他....
			
			
			
			（8）webpack：代码编译,打包 压缩
	
		
	
			（2）editorconfig：
	
		



		（6）ES6模块的导入和导出
			
		
				
			1，模块的导入：import 变量 from 路径  来引入组件
	
	
	
			2，使用export default来导出我们的组件
	
	
		
		
		（6）vue的单文件和入口的解析：
	
	

	
			1，main.js：整个项目的入口文件
	
	
	
			2，App.vue：整个项目的根组件
	
	
			
			3，单文件组件：一个.vue的文件就是一个组件
	
			
			
			4，注意：vue选项中的render函数若是存在，则Vue构造函数不会从template`选项或通过 `el` 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。
			
	
			
			5，介绍：
	

				
				（1）在cli开发模式下，一个.vue就是一个文件就是一个组件
	
	
	
				（2）template 组件的页面结构 代表它的 html 结构 
	
	
	
				（3）必须在里面放置一个 html 标签来包裹所有的代码 
	
	

				（4）我们在其他地方写好了一个组件，然后就可以在当前template中引入
			
	

				（5）script ：组件的逻辑结构及数据对象
	
		
				
				（6）style 组件的样式：就是针对我们的 template 里内容出现的 html 元素写一些样式 
		